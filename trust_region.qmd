---
title: "Trust Region"
format: html
---

```{python}
import numpy as np
import pandas as pd
import networkx as nx

import scipy as sp

import ags.relaxationmethods.utils
from ags.relaxationmethods.graph_instances import GNMInstance

import seaborn as sns
sns.set_theme()
```


```{python}
nNodes = 5
mEdges = 7
instance = GNMInstance(5, 7)

# G0 = nx.barabasi_albert_graph(nNodes, 5)

nx.draw(instance.graph, labels = {x:x for x in instance.graph.nodes()})
```


```{python}
from ags.relaxationmethods.trustregion import TrustRegionSolver

# ps = np.linspace(0, 1, num=10)
ps = [0.5]
# ns = np.logspace(1, 3, num=10, dtype=int)
ns = [32]

solver = TrustRegionSolver(init_method='uniform')
if False:
    for p in ps:
        for n in ns:
            m = int(p * n)
            print(n, m)
            instance = GNMInstance(n, m)
            solver.formulate(instance)
            res = solver.solve()
            print(res)

```



```{python}
import random
import itertools

if False:
    for n in range(7, 12):
        graph = generate_asymmetric_graph(n)
        nx.write_adjlist(graph, f"asymmetric_{n}.adjlist")
        nx.write_adjlist(nx.complement(graph), f"asymmetric_{n}_complement.adjlist")
        nx.draw_kamada_kawai(graph)
        nx.draw_kamada_kawai(nx.complement(graph), node_color="red")

```


```{python}
from scipy.optimize import linear_sum_assignment
import pandas as pd

from ags.relaxationmethods.graph_instances import GraphInstance
from ags.relaxationmethods.trustregion import NonConvexRelaxation
from ags.relaxationmethods.utils import permutation_to_matrix, _compE, _compS, compES


solver = TrustRegionSolver(init_method='uniform')
G = nx.read_adjlist("./data/asymmetric/asymmetric_11.adjlist")
instance = GraphInstance(G)

class CollectIterationData:
    def __init__(self, instance):
        self.instance = instance
        self.data = {
            "iter": [],
            "P_hat": [],
            "E_relax": [],
            "S_relax": [],
            "E_hat": [],
            "S_hat": [],
            "obj": [],
        }

        self.solution_leading_to_lowest_obj = None
        self.lowest_obj = float('inf')

    def __call__(self, intermediate_result):
        x = intermediate_result.x
        n = int(np.sqrt(x.size))
        D = x.reshape((n, n))

        _, col = linear_sum_assignment(-D)

        A = self.instance.adjacency

        P = permutation_to_matrix(col)
        E_relax = _compE(A, D)
        S_relax = _compS(A, D, E=E_relax)
        E_hat = _compE(A, P)
        S_hat = _compS(A, P, E=E_hat)  

        self.data["iter"].append(intermediate_result.nit)
        self.data["P_hat"].append(col)
        self.data["E_relax"].append(E_relax)
        self.data["S_relax"].append(S_relax)
        self.data["E_hat"].append(E_hat)
        self.data["S_hat"].append(S_hat)
        self.data["obj"].append(intermediate_result.fun)

        if intermediate_result.fun < self.lowest_obj:
            self.lowest_obj = intermediate_result.fun
            self.solution_leading_to_lowest_obj = D

    
    def to_dataframe(self):
        return pd.DataFrame(self.data)

solver.formulate(instance)
cb = CollectIterationData(instance)
res = solver.solve(NonConvexRelaxation(instance), callback=cb)
print(res)

df_test = cb.to_dataframe()
```

```{python}
hlp = df_test.melt(
    id_vars=["iter"],
    value_vars=["S_relax", "S_hat"],
    var_name="metric",
    value_name="value",
)
sns.relplot(data=hlp, x="iter", y="value", hue="metric", aspect=2)
```

```{python}
from ags.relaxationmethods.trustregion import NonConvexRelaxationPenalized, DynamicFixedPointsGMP, NonConvexRelaxation

G = nx.erdos_renyi_graph(n=30, p=0.5)
instance = GraphInstance(G)
solver = TrustRegionSolver(init_method="random")
solver.formulate(instance)
cb = CollectIterationData(instance)
# obj = NonConvexRelaxation(instance)
# obj.jacobian = None
# obj.hessian = None
obj = NonConvexRelaxationPenalized(instance, c=0.2)
#obj = DynamicFixedPointsGMP(instance)
res = solver.solve(obj, callback=cb)

# Plot data
df = cb.to_dataframe()
print(df)
print(df.iloc[-1]["P_hat"])
hlp = df.melt(
    id_vars=["iter"],
    value_vars=["S_relax", "S_hat"],
    var_name="metric",
    value_name="value",
)

sns.relplot(data=hlp, x="iter", y="value", hue="metric", aspect=2, kind="line")
sns.relplot(data=df, x="iter", y="obj", aspect=2, kind="line")
sns.relplot(data=df, x="iter", y="S_hat", aspect=2, kind="line")
sns.relplot(data=df, x="iter", y="S_relax", aspect=2, kind="line")
```

When computing with exact gradient there seems to be an extreme spike in S_relax whether when using a numerically approximated gradient and hessian the curves S_relax and S_hat seems to be more in line.

```{python}
import numpy as np
import networkx as nx
from scipy.optimize import approx_fprime, minimize
from ags.relaxationmethods.trustregion import NonConvexRelaxation, NonConvexRelaxationPenalized
from ags.relaxationmethods.graph_instances import GraphInstance

import jax.numpy as jnp
from jax import hessian, jacobian


def g(x, c=0.2):
    n = instance.n
    A = instance.adjacency
    P = x.reshape(n, n)
    c_mat = np.diag(jnp.ones(n) * c)
    return -jnp.trace(A @ P @ A.T @ P.T - c_mat @ P)

epsilon = np.sqrt(np.finfo(float).eps)  # Small step size
n = 5
G = nx.erdos_renyi_graph(n, p=0.5)
instance = GraphInstance(G)

P0 = np.ones((n, n)) / n
x0 = P0.reshape(n * n)
f = NonConvexRelaxationPenalized(instance, c=0.2)
grad_approx = jacobian(g)(x0).reshape(n, n)
grad_exact = f.jacobian(P0)
print(grad_approx, grad_exact)
print(np.allclose(grad_approx, grad_exact))

hess_approx = hessian(g)(x0)
hess_exact = f.hessian(P0)

print(hess_approx)
print(hess_exact)
np.allclose(hess_approx, hess_exact)
```


```{python}
# read and solve pidnebesna
from pathlib import Path
import pickle
import time
import json
import os
import shutil
import numpy as np
import networkx as nx

from ags.relaxationmethods.trustregion import NonConvexRelaxation, NonConvexRelaxationPenalized
from ags.relaxationmethods.graph_instances import GraphInstance

from scipy.optimize import linear_sum_assignment

from ags.relaxationmethods.graph_instances import GraphInstance
from ags.relaxationmethods.trustregion import NonConvexRelaxation
from ags.relaxationmethods.utils import permutation_to_matrix, _compE, _compS, compES
from ags.relaxationmethods.trustregion import TrustRegionSolver

no_iterations = 1

instance_folder = Path("data/pidnebesna")
output_folder = Path("output/")
if output_folder.exists():
    shutil.rmtree(output_folder)

# graph_type_folders = [ dir for dir in instance_folder.iterdir() if dir.is_dir() ]
graph_type_folders = [Path('data/pidnebesna/ER')]
for graph_type_folder in graph_type_folders:
    graph_type = graph_type_folder.name
    print(graph_type)
    instances = [
        instance
        for instance in graph_type_folder.iterdir()
        if instance.is_file()
        if not '_allInfo' in instance.name
    ]

    for instance in instances:
        instance_name = instance.name.strip('.p')
        print(instance_name)
        with open(instance, 'rb') as fin:
            data = pickle.load(fin)
            print(list(data.keys()))
            for simulation in range(39):
                print(simulation, data[simulation].shape)
                A = data[simulation]
                n = A.shape[0]
                G = nx.from_numpy_array(A)
                instance = GraphInstance(G)
                for init_method in ["random", "uniform"]:
                        solver = TrustRegionSolver(init_method="random")
                        solver.formulate(instance)
                        obj = NonConvexRelaxationPenalized(instance, c=0.2)
                        for run in range(no_iterations):
                            tick = time.time()
                            res = solver.solve(obj)
                            tock = time.time()

                            elapsed = tock - tick

                            x = res.x
                            D = x.reshape((n, n))
                            _, pi = linear_sum_assignment(-D)
                            P = permutation_to_matrix(pi)
                            S_hat = _compS(A, P)

                            print(elapsed)
                            print(S_hat)

                            #  method_generla/ method_version / graph_model
                            method_general = solver.__class__.__name__
                            method_version = f"{obj.__class__.__name__}_{init_method}"
                            graph_model = graph_type

                            outdir = output_folder / method_general / method_version / graph_model
                            outdir.mkdir(parents=True, exist_ok=True)

                            info_filename = f"{instance_name}.{simulation}.{run}.json"
                            info = {
                                "time": elapsed,
                                "S(A)": S_hat,
                            }
                            with open(outdir / info_filename, "w") as fout:
                                json.dump(info, fout)

                            perm_dir = outdir / "permutations"
                            perm_dir.mkdir(parents=True, exist_ok=True)

                            perm_filename = f"{instance_name}.{simulation}.{run}.csv"
                            np.savetxt(perm_dir / perm_filename, pi, delimiter=",", fmt="%d")

```


```{python}
import numpy as np
import matplotlib.pyplot as plt

# Define x-values for both segments
x1 = np.linspace(0, 1, 200)
x2 = np.linspace(1, 2, 200)

# Define the PDF for each segment
y1 = x1
y2 = 2 - x2

plt.figure(figsize=(8, 5))
plt.plot(x1, y1, label=r'$f_Z(z)=z$', color='blue')
plt.plot(x2, y2, label=r'$f_Z(z)=2-z$', color='blue')
plt.fill_between(x1, y1, color='blue', alpha=0.2)
plt.fill_between(x2, y2, color='blue', alpha=0.2)
plt.xlabel('z')
plt.ylabel(r'$f_Z(z)$')
plt.title('PDF of \( Z = X + Y \)')
plt.legend()
plt.grid(True)
plt.show()
```


```{python}
import numpy as np
import matplotlib.pyplot as plt

def fW(w):
    """PDF of W = X + Y + Z, where X,Y,Z ~ Uniform(0,1)."""
    if w < 0 or w > 3:
        return 0.0
    else if 0 <= w < 1:
        return 0.5 * w**2
    else if 1 <= w < 2:
        return -w**2 + 3*w - 1.5
    else:  # 2 <= w <= 3
        return 0.5 * (3 - w)**2

# Generate points in a region covering the support [0,3]
x_vals = np.linspace(-0.5, 3.5, 400)
y_vals = [fW(x) for x in x_vals]

plt.figure(figsize=(8,5))
plt.plot(x_vals, y_vals, color='blue', label='PDF of W = X + Y + Z')
plt.fill_between(x_vals, y_vals, where=(y_vals>=0), color='blue', alpha=0.2)
plt.xlabel('w')
plt.ylabel('f_W(w)')
plt.title('PDF of the Sum of 3 Independent Uniform(0,1) Random Variables')
plt.grid(True)
plt.legend()
plt.show()

```