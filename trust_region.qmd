---
title: "Trust Region"
format: html
---

```{python}
import numpy as np
import pandas as pd
import networkx as nx

import scipy as sp

import seaborn as sns
sns.set_theme()
```


```{python}
class GNMInstance:
    def __init__(self,no_nodes, no_edges, seed=None):
        self.no_nodes = no_nodes
        self.no_edges = no_edges

        self._graph = None
        self._adjacency = None

    def _generate(self):
        self._graph = nx.gnm_random_graph(self.no_nodes, self.no_edges)

    @property
    def n(self):
        return self.no_nodes

    @property
    def m(self):
        return self.no_edges

    @property
    def adjacency(self):
        if self._adjacency is not None:
            return self._adjacency

        self._adjacency = nx.to_numpy_array(self.graph)
        return self._adjacency

    @property
    def graph(self):
        if self._graph is None:
            self._generate()

        return self._graph


class GraphInstance:
    def __init__(self, G: nx.Graph):
        self.no_nodes = G.number_of_nodes()
        self.no_edges = G.number_of_edges()

        self._graph = G
        self._adjacency = None

    @property
    def n(self):
        return self.no_nodes

    @property
    def m(self):
        return self.no_edges

    @property
    def adjacency(self):
        if self._adjacency is not None:
            return self._adjacency

        self._adjacency = nx.to_numpy_array(self.graph)
        return self._adjacency

    @property
    def graph(self):
        return self._graph


```

```{python}
nNodes = 5
mEdges = 7
instance = GNMInstance(5, 7)

# G0 = nx.barabasi_albert_graph(nNodes, 5)

nx.draw(instance.graph, labels = {x:x for x in instance.graph.nodes()})
```

```{python}
class ObjectiveFunction():
    def __init__(self, instance):
        self._instance = instance

    def __call__(self, *args, **kwargs):
        raise NotImplementedError("Objective function call not implemented")

    def jacobian(self):
        raise NotImplementedError("Jacobian not defined")

    def hessian(self):
        raise NotImplementedError("Hessian not defined")

class NonConvexRelaxation(ObjectiveFunction):
    def __call__(self, x):
        n = self._instance.n
        A = self._instance.adjacency
        P = x.reshape(n, n)
        return -np.trace(A @ P @ A.T @ P.T)

class NonConvexRelaxationPenalized(ObjectiveFunction):
    def __init__(self, instance, c):
        self._instance = instance

        self.c_mat = np.diag(np.ones(instance.n) * c)

    def __call__(self, x):
        n = self._instance.n
        A = self._instance.adjacency
        P = x.reshape(n, n)
        return -np.trace(A @ P @ A.T @ P.T - self.c_mat @ P)

class DynamicFixedPointsGMP(ObjectiveFunction):
    def __init__(self, instance):
        self._instance = instance

    def __call__(self, x):
        n = self._instance.n
        A = self._instance.adjacency
        P = x.reshape(n, n)
        E = np.linalg.norm(A - P @ A @ P.T, 'fro')

        # Relaxed notion of a fixed point
        F = np.trace(P)

        return E / (n * (n - 1) - 2 * F * (F - 1))
```

```{python}
from scipy.optimize import Bounds
from scipy.optimize import LinearConstraint
from scipy.optimize import minimize

def permutation_to_matrix(pi):
    n = len(pi)
    Im = np.eye(n)
    return Im[:,pi]

def random_petmuation_matrix(n):
    # TODO: Use seed
    pi = np.random.permutation(n)
    return permutation_to_matrix(pi)


def doubly_stochastic(P: np.ndarray, tol: float = 1e-9) -> np.ndarray:
    # Adapted from @btaba implementation
    # https://github.com/btaba/sinkhorn_knopp
    # of Sinkhorn-Knopp algorithm
    # https://projecteuclid.org/euclid.pjm/1102992505

    max_iter = 1000
    c = 1 / P.sum(axis=0)
    r = 1 / (P @ c)
    P_eps = P

    for it in range(max_iter):
        if (np.abs(P_eps.sum(axis=1) - 1) < tol).all() and (
            np.abs(P_eps.sum(axis=0) - 1) < tol
        ).all():
            # All column/row sums ~= 1 within threshold
            break

        c = 1 / (r @ P)
        r = 1 / (P @ c)
        P_eps = r[:, None] * P * c

    return P_eps


class TrustRegionSolver:

    def __init__(
        self,
        init_method="uniform",
    ):
        assert init_method in ("uniform", "random")

        self._init_method = init_method

        self._instance = None
        self._formulated = False

        self._dimension = None
        self._constraint_matrix = None
        self._rhs = None
        self._lower_bounds = None
        self._upper_bounds = None

    def formulate(self, instance):
        self._instance = instance
        self._formulated = False

        self._dimension = instance.n * instance.n

        M, b = self._formulate_constraints()

        self._constraint_matrix = M
        self._rhs = b
        self._lower_bounds = np.zeros(self._dimension)
        self._upper_bounds = np.ones(self._dimension)

        self._formulated = True

    def _formulate_constraints(self):
        n = self._instance.n

        # Constraints
        ## Row sums
        M1 = sp.sparse.kron(np.ones(n), sp.sparse.eye(n))
        b1 = np.ones(n)

        ## Columns sums
        M2 = sp.sparse.kron(sp.sparse.eye(n), np.ones(n))
        b2 = np.ones(n)

        # Constraint Matrix
        M = sp.sparse.vstack([M1, M2])

        # RHS
        b = np.hstack([b1, b2])

        return M, b

    def _initial_point(self):
        assert self._formulated

        if self._init_method == 'uniform':
            return np.ones(self._dimension) / self._instance.n
        elif self._init_method == 'random':
            n = self._instance.n
            S = np.random.random((n, n))
            return doubly_stochastic(S)
        else:
            raise NotImplementedError()

    def solve(self, obj, callback=None):
        assert self._formulated

        linear_constraints = LinearConstraint(
            self._constraint_matrix, self._rhs, self._rhs
        )
        variable_bounds = Bounds(self._lower_bounds, self._upper_bounds)

        P_0 = self._initial_point()
        x_0 = P_0.flatten()

        res = minimize(
            obj,
            x_0,
            method="trust-constr",
            constraints=[linear_constraints],
            bounds=variable_bounds,
            options={"verbose": 1},
            callback=callback
        )
        self._result = res

        return res
```

```{python}
# ps = np.linspace(0, 1, num=10)
ps = [0.5]
# ns = np.logspace(1, 3, num=10, dtype=int)
ns = [32]

solver = TrustRegionSolver(init_method='uniform')
if False:
    for p in ps:
        for n in ns:
            m = int(p * n)
            print(n, m)
            instance = GNMInstance(n, m)
            solver.formulate(instance)
            res = solver.solve()
            print(res)

```



```{python}
# The 4 smallest asymmetric graphs

ASYMMETRIC_GRAPH_1 = nx.Graph()
ASYMMETRIC_GRAPH_1.add_nodes_from(range(6))
ASYMMETRIC_GRAPH_1.add_edges_from(
    [
        (0, 1),
        (1, 2),
        (2, 3),
        (3, 4),
        (1, 5),
        (5, 2),
    ]
)

ASYMMETRIC_GRAPH_2 = nx.Graph()
ASYMMETRIC_GRAPH_2.add_nodes_from(range(6))
ASYMMETRIC_GRAPH_2.add_edges_from(
    [
        (0, 1),
        (1, 3),
        (0, 2),
        (2, 3),
        (2, 4),
        (3, 5),
        (3, 4),
    ]
)

ASYMMETRIC_GRAPH_3 = nx.Graph()
ASYMMETRIC_GRAPH_3.add_nodes_from(range(6))
ASYMMETRIC_GRAPH_3.add_edges_from(
    [
        (0, 1),
        (0, 2),
        (1, 2),
        (1, 3),
        (2, 4),
        (3, 4),
        (3, 5),
    ]
)

ASYMMETRIC_GRAPH_4 = nx.Graph()
ASYMMETRIC_GRAPH_4.add_nodes_from(range(6))
ASYMMETRIC_GRAPH_4.add_edges_from(
    [
        (0, 1),
        (0, 2),
        (0, 3),
        (1, 3),
        (2, 3),
        (2, 4),
        (3, 5),
    ]
)


nx.draw_kamada_kawai(ASYMMETRIC_GRAPH_4)
```


```{python}
import random
import itertools

def is_symmetric(G: nx.Graph):
    n = G.number_of_nodes()

    pis = itertools.permutations(range(n))
    # Skip the identity
    next(pis)

    A = nx.to_numpy_array(G)
    print(G.adjacency)
    for pi in pis:
        P = permutation_to_matrix(pi)
        if np.array_equal(A @ P, P @ A):
            return True

    return False

def generate_asymmetric_graph(n, p=0.5):
    print(f"Generating random asymmetric graph n={n} p={p}")
    count = 0
    while True:
        print(f"{count}")
        G = nx.erdos_renyi_graph(n, p)

        print(G)
        if is_symmetric(G):
            count += 1
            continue

        break

    return G

if False:
    for n in range(7, 12):
        graph = generate_asymmetric_graph(n)
        nx.write_adjlist(graph, f"asymmetric_{n}.adjlist")
        nx.write_adjlist(nx.complement(graph), f"asymmetric_{n}_complement.adjlist")
        nx.draw_kamada_kawai(graph)
        nx.draw_kamada_kawai(nx.complement(graph), node_color="red")

```

```{python}
def _compE(A, P):
    return 1/4 * np.linalg.norm(A - P @ A @ P.T, 'fro')**2

def _compS(A, P, E=None):
    if E is None:
        E = _compE(A, P)

    n = int(np.sqrt(P.size))
    return 4*E/(n*(n-1))

def compES(A, perm):
    """
    Compute E(A) (1.1) and S(A) (1.2)
    """

    P = permutation_to_matrix(perm)
    N = len(perm)
    E = _compE(A, P)
    S = _compS(A, P, E=E)
    return E, S
```


```{python}
from scipy.optimize import linear_sum_assignment
import pandas as pd


solver = TrustRegionSolver(init_method='uniform')
G = nx.read_adjlist("./data/asymmetric/asymmetric_11.adjlist")
instance = GraphInstance(G)

class CollectIterationData:
    def __init__(self, instance):
        self.instance = instance
        self.data = {
            "iter": [],
            "P_hat": [],
            "E_relax": [],
            "S_relax": [],
            "E_hat": [],
            "S_hat": [],
            "obj": [],
        }

    def __call__(self, intermediate_result):
        x = intermediate_result.x
        n = int(np.sqrt(x.size))
        D = x.reshape((n, n))

        _, col = linear_sum_assignment(-D)

        A = self.instance.adjacency

        P = permutation_to_matrix(col)
        E_relax = _compE(A, D)
        S_relax = _compS(A, D, E=E_relax)
        E_hat = _compE(A, P)
        S_hat = _compS(A, P, E=E_hat)  

        self.data["iter"].append(intermediate_result.nit)
        self.data["P_hat"].append(col)
        self.data["E_relax"].append(E_relax)
        self.data["S_relax"].append(S_relax)
        self.data["E_hat"].append(E_hat)
        self.data["S_hat"].append(S_hat)
        self.data["obj"].append(intermediate_result.fun)
    
    def to_dataframe(self):
        return pd.DataFrame(self.data)

solver.formulate(instance)
cb = CollectIterationData(instance)
res = solver.solve(NonConvexRelaxation(instance), callback=cb)
print(res)

df_test = cb.to_dataframe()
```

```{python}
hlp = df_test.melt(
    id_vars=["iter"],
    value_vars=["S_relax", "S_hat"],
    var_name="metric",
    value_name="value",
)
sns.relplot(data=hlp, x="iter", y="value", hue="metric", aspect=2)
```

```{python}
import matplotlib.pyplot as plt
```

```{python}
G = nx.erdos_renyi_graph(n=20, p=0.5)
instance = GraphInstance(G)
solver = TrustRegionSolver(init_method="random")
solver.formulate(instance)
cb = CollectIterationData(instance)
obj = NonConvexRelaxationPenalized(instance, c=0.2)
res = solver.solve(obj, callback=cb)

# Plot data
df = cb.to_dataframe()
print(df)
print(df.iloc[-1]["P_hat"])
hlp = df.melt(
    id_vars=["iter"],
    value_vars=["S_relax", "S_hat"],
    var_name="metric",
    value_name="value",
)

sns.relplot(data=hlp, x="iter", y="value", hue="metric", aspect=2, kind="line")
sns.relplot(data=df, x="iter", y="obj", aspect=2, kind="line")
```


```{python}

```